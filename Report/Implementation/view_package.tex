The \texttt{View} package contains all the classes managing the graphical user interface.


\subsubsection{View class} % Front end class in the MVC pattern. Contains the rest of the (non-static) GUI classes. Implements the MapListener interface. The overall class structure of the View package
The \texttt{View} class is the front-end class of the \texttt{View} package in the MVC design pattern. It contains an instance of the \texttt{MainFrame} class, which is the topmost \texttt{java.swing} GUI container (the window to be displayed), which then again contains an instance of our custom panels, the \texttt{MapPanel} and the \texttt{SearchPanel}.

The \texttt{View} itself implements the interfaces \texttt{MapListener} and \texttt{SearchListener}. An instance of the \texttt{MapListener} is stored in both the \texttt{MainFrame} and the \texttt{MapPanel} classes. This allows for these classes to invoke a method in the \texttt{View}, telling it that changes have been made. This then invokes a similar method in the \texttt{Controller}, which then updates the GUI according the the changes. An instance of the \texttt{SearchListener} is stored in the \texttt{SearchPanel}, giving the same possibilities.

\subsubsection{ViewValues class}
The \texttt{ViewValues} class is a singleton containing all values concerning both the initial and current "viewbox" values such as the min and max values for the x- and y-coordinates (UTM), the types of road segments to be drawn, the dimensions of the map in pixels etc.

The only instance of the class is obtained by the classes needing access to the contained information through a static method in the class.

The values contained are changed in the \texttt{View} package according to user interaction with the map. The values are then used for the filtering, conversion etc. in the \texttt{Model} package.

\subsubsection{MapPanel class} % Draws lines according to input data
The \texttt{MapPanel} class extends the \texttt{java.swing.JPanel} class and functions as a panel with extended functionality and with an overridden \texttt{paint} method.

The \texttt{MapPanel} stores an \texttt{int[][][]} (as generated by the \texttt{FormatConverter}), from which it draws lines of the canvas, each corresponding to an edge stored in the \texttt{Model}. It also stores an instance of the \texttt{MapLocation} and \texttt{Trip} classes (which both can be null), which are then drawn similarly to the roads, given that they are not null. The \texttt{MapLocation} is displayed as a filled circle, whereas the \texttt{trip} is displayed by drawing each of the road segments of which it consists.

The \texttt{MapPanel} also has two listeners from the \texttt{java.awt} library; a \\\texttt{MouseWheelListener}, which invokes a static method of the \texttt{ZoomHandler} class when the user scrolls on the panel, sending data about the mouse coordinates and the scrolled amount, and a \texttt{MouseMotionListener}, which invokes a static method of the \texttt{DragHandler} class when the user drags the mouse on the panel, letting the \texttt{DragHandler} know how far the mouse has been dragged (and along which axes).

\subsubsection{ZoomHandler class} % Handles all the zooming
The \texttt{ZoomHandler} handles all zooming. When a call is received (from the \texttt{MapPanel}), signaling that the user wishes to zoom \textsl{out}, there are two possible outcomes: If the current viewbox is not too close to the maximum width and height values, it zooms out, maintaining the current center of the viewbox. Otherwise, if the viewbox is near its extrema, zooming is done with the viewbox bound to the borders imposed by the maximum values.

Subsequently, when zooming \textsl{in}, a call is made to the \texttt{DragHandler} class, moving the viewbox towards the current location of the cursor.

Zooming is simply a matter of changing values indicating what is being displayed (in the instance of the \texttt{ViewValues} class) / changing the size of the viewbox and then invoking a repaint of the \texttt{MapPanel}.

\subsubsection{DragHandler class} % Handles all the dragging
The \texttt{DragHandler} class, like the \texttt{ZoomHandler} class, changes the viewbox according to input data (drag amount and direction) and according the maximum values that define the extrema of the viewbox.

\subsubsection{SearchPanel class}
Like the \texttt{MapPanel} class, the \texttt{SearchPanel} class extends \texttt{javax.swing.JPanel}.

The \texttt{SearchPanel} contains components used for searching for addresses; two \texttt{JTextFields} allowing the user to input up to two addresses, two \texttt{JLists} for displaying proposed addresses to the user, two \texttt{JButtons}, one for executing a search for either a location corresponding to an address, or a search for a trip from one given address to another, and one for swapping the content of the text fields, two \texttt{JRadioButtons} in a \texttt{ButtonGroup} for toggling between searching for either the fastest or the shortest trip.

The \texttt{SearchPanel} has several \texttt{JLabels}. Each component used for user interaction is labelled with explaining text. Below these components, there are labels displaying the following info about the trip:
\begin{itemize}
 \item The distance of the trip in meters.
 \item The computed time of the trip in minutes.
\end{itemize}
given a such search has been executed recently (and a search for a location has not been made since).

All component listeners on the \texttt{SearchPanel} (be it \texttt{ActionListeners}, \texttt{DocumentListeners} etc.) either only affect things within the \texttt{SearchPanel} class or signal for the \texttt{SearchListener} (in this case the \texttt{View} class) to take action according to the input given by the user.

\subsubsection{AddressParser class}
The \texttt{ParseAddress} method is the heart of the \texttt{AddressParser} class. It uses regular expressions and pattern matching to parse an input address. The basic idea is that an input address can consist of up to three different parts:
\begin{itemize}
	\item Zero, one, or two city name / street name parts consisting of the characters allowed in them (we refer to this as "\textit{name}").
	\item Zero or one zip code part consisting of digits (we refer to this as "\textit{zip}").
	\item Zero or more parts containing the characters not allowed elsewhere, which allows the other parts to be determined from each other (we refer to this as "\textit{other}").
\end{itemize}
The input \texttt{String} is matched with up to three different patterns (we use the \# as a separator. The words \underline{underlined} must be present, the rest are optional):
\begin{itemize}
	\item Pattern with the zip code last: \\
		\textit{other\#\underline{name}\#other\#name\#other\#zip\#other}
	\item Pattern with the zip code first \\
	\textit{other\#\underline{zip}\#other\#name\#other\#name\#other}
	\item Pattern with the zip code in the middle \\
	\textit{other\#\underline{name\#other\#zip}\#other\#name\#other}
\end{itemize}
If the first pattern matches, the city name, street name and zip code (or at least the parts found) are parsed to the format \textit{city name\#zip code\#street name}. If it does not match, the parser tries matching the input with the next pattern, parsing to the same format, and so on. If none of the patterns match, \texttt{null} is returned.

The \texttt{ParseAddressLive} method makes use of the \texttt{ParseAddress} method, but it cleans up the result for it to be optimal for doing a prefix search in the \texttt{TernaryTrie}. It removes any "empty" parts of the address which are in either the beginning or in the end of the parse address. An example is the parsed address \textit{\#1234\#}, which will be cleaned to being simply \textit{1234}.

\subsubsection{TernaryTrie class}
\label{sec:TernaryTrie class}
The \texttt{TernaryTrie} has the purpose of storing addresses, allowing efficient prefix searches and searches for a node id corresponding to a given address.

The search trie uses an internal node representation of characters to build a ternary tree, where each branch represents a searchable address.
The tree structure makes it possible to search for a given string in time that is $\sim\ln(N)$ for a search miss and  $\sim K+1$ for a search hit, where K is the length of the string to search for.
In practise, on a 5 year old computer with a 2.4 Ghz Intel dual-core processor, we have measured the prefix searches to take about one hundredth of a second on our trie data set.

The trie  provides a simple API for searches:
\begin{itemize}
	\item \texttt{String} get(\texttt{String}) returns the node id associated with the search \texttt{String}, or \texttt{null} if the search is a miss
	\item \texttt{Iterable<String>} startsWith(\texttt{String}) returns all \texttt{String}s that are prefixed with the given \texttt{String}, or null if no such \texttt{String}s are found.
\end{itemize}
