For quite a long period we had great trouble making the path-finding searches using Dijksta's algorithm. A single search could easily take more than 30 seconds to finish. We had a lot of trouble figuring out what caused this slow search. We tried implementing the A* algorithm instead, but without any luck. Due to this slow search we started looking at the opportunity to make the path-finding run in a separate thread, giving the user the possibility to still navigate and explore the map while searching for a path. 

This was, however, after a meeting with Rasmus Pagh, not a problem anymore, since we found out that the priority queue that our Dijkstra implementation used was very slow and actually running in linear time when removing things. By deleting the part of the implementation where the non-fastest roads are removed from the priority queue, our path-finding search was now done in less than 0.5 seconds, and we did no longer see any reason to run the path-finding in a separate thread. Deciding not to remove the these non-fastest roads anymore resulted in a slight increase in memory usage, but we believe that the speed we have gained by doing so more than makes up for it. Also, since these roads are not the fastest between two given points, they will never be looked at again and are, as far as the algorithm is concerned, essentially gone.

It did however turn out that the priority queue that did not use a remove function, had some problems finding the shortest path sometimes. Due to this we decided to implement another priority queue than Java's standard priority queue. The new priority queue is taken from the algs4.cs.princeton.edu homepage by Robert Sedgewick and Patrick Wayne. Using this priority queue fixes our problem concerning the problem of not always finding the shortest path.
