In this section we will account for the choices we have made, in regard to the data structures we have used to support our application.

The choice of data structures to be used is essential to the overall performance of the application, since they are the heart of almost every operation. The critical operations are:
\begin{itemize}
	\item Filtering all edges stored according to a part of the map and the types of edges to be displayed
	\item Finding the shortest or fastest path from one location to another
	\item Finding the locations corresponding to addresses typed in by the user
	\item Finding suggested addresses according to user input while the input is being typed in
\end{itemize}

\subsubsection{Storing and filtering edges}
We use a Quadtree containing all edges, allowing quite fast filtering of the edges according to the given criteria. The user interface must not block during the basic map navigation operations, zooming and panning (some milliseconds of blockage are accepted, as long as it does not render the map navigation too annoying or even useless).

\subsubsection{Path finding}
We have decided to use two graphs for path finding; one containing edges weighted by time and one containing edges weighted by their length. The first of the two is used to compute the fastest path from one given point to another, and the latter  to compute the shortest path.

This decision has both its pros and its cons. On the up-side, it adds additional functionality which is the choice between fastest or shortest path. On the down-side, having two graphs uses more memory.

The shortest path graph could be expanded to allow the choice between different types of transportation (such as walking or cycling).

\subsubsection{Storing the address}
All possible addresses are stored in a ternary trie, allowing for fast prefix searches for the automatic text completion to function without blockage (again, a few milliseconds of blockage is accepted). It also allows for the id corresponding to a given address to be found very quickly.

\subsubsection{Preprocessed files}
We decided on using preprocessed files containing the edge and vertex data needed to create graphs for path finding, quadtrees for filtering edges, and the ternary trie for address finding. The files contain only the information that is strictly necessary to serve their purposes, and since the files only need to be created once (ever), this can be done outside of the application, decreasing the start-up time of the application itself.
